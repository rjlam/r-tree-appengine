\documentclass{scrartcl}
\usepackage{color}
\usepackage{url}
\usepackage{cite}
\usepackage{eucal}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{caption,subcaption}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsmath}
%
\newcommand{\TODO}[1]{\textcolor{red}{\boxed{\mathbf{TODO }} {\textit{#1}} }}
\newcommand{\REMARK}[1]{\textcolor{blue}{\boxed{\mathbf{Remark }} {\textit{#1}} }}
\newcommand{\todo}{\TODO}
\newcommand{\remark}{\REMARK}
\newcommand{\email}[1]{\texttt{#1}}
%
% for algorithms2e
\LinesNumbered
\begin{document}

\title{RNav - R-Tree Navigation Helper on Google App Engine}
\subtitle{CS 764 - Spring 2013 - Innovation Project}

\author{
Aaron Gorenstein\\
	\email{agorenst@cs.wisc.edu}
\and
Rebecca Lam\\
	\email{rjlam@cs.wisc.edu}
\and
Cathrin Weiss\\
	\email{cweiss@cs.wisc.edu}       
}

\date{\today}

\maketitle

%====== OVERVIEW =======================
\section{Overview}
\label{sec:intro}
Google App Engine (GAE) allows for rapid development of web applications without worrying about maintenance or scalability\footnote{\url{https://developers.google.com/appengine/}}. It follows the key-value storage paradigm for persistent as well as in-memory storage. 

We developed a route planning application leveraging an R-Tree structure on the server side. Using the California Roads data set~\cite{Online:cardata}, we provide route guidance functionality given two input points A and B (assuming A and B are within the described area). The project consists of six components:

\begin{enumerate}
\item The R-Tree data loader, which will convert the geo data into a key-value-compatible R-Tree index (this and part 1 may possibly be combined)
\item The actual R-Tree index, which can process the native R-Tree operations,
\item An algorithm module to compute the shortest route from point A to point B,
\item A simple query engine to process navigation requests, 
\item A query frontend for entering route requests, and
\item A result generator to present the final route to the user. 
\end{enumerate}

Currently Datastore (the GAE key-value store) does not have native support for indexing spatial data and also uses a non-relational database model. Thus, our main challenge for this project was transposing the traditional R-Tree implementation in~\cite{DBLP:conf/sigmod/Guttman84} into its GAE equivalent.

The architecture of our project is presented in section~\ref{sec:architecture}. 

%====== ARCHITECTURE ==================
\section{Architecture}
\label{sec:architecture}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{fig/gapps1}
\caption{Google App Engine default architecture}
\label{fig:gappsArch}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{fig/gapps2}
\caption{Google App Engine architecture with R-Tree index}
\label{fig:gappsArch2}
\end{center}
\end{figure}

The architecture of a common Google App Engine application is depicted in Figure~\ref{fig:gappsArch}. A user makes a web request, which gets forwarded to the Python backend, which itself processes the request and interacts with the data store. The data can either be stored persistently or in memory. The latter is referred to as ``Memcache''. Usually data access follows standard key-value protocols. For our project we created an R-Tree index within GAE Datastore to efficiently serve spatial queries. This is schematically shown in Figure~\ref{fig:gappsArch2}. The actual R-Tree layout and implementation is described in Section~\ref{sec:implementation}.

Additionally, we implemented a route-finding algorithm, which takes as input the list of roads retrieved via the R-Tree lookup and generates a route from point A to point B. The resulting is presented to the querying user in a graphical result view.

%====== IMPLEMENTATION ==================
\section{Implementation}
\label{sec:implementation}
\subsection{R-Tree layout in Datastore}
Datastore is a distributed schemaless key-value object datastore that is designed for scalability~\cite{datastore}. It only allows for certain data types to be stored and does not support certain operations such as joins and filtering on multiple attributes. It is possible to store basic data types like integers, short strings, text, and also generic blob data. A Datastore key is composed of a unique identifier and an optional name. When storing an object for the first time, a unique key identifier is automatically created and can be accessed via the Datastore API. 

It is not possible to directly store general objects. Because of this it is not entirely straightforward how to store an R-Tree, which is composed of three non-standard object types: rectangles, entries, and nodes. Recall from Guttman's paper\cite{DBLP:conf/sigmod/Guttman84} that there are two types of nodes in an R-tree: internal and leaf. All nodes have a list of entries describing its children. An internal node entry is of the form ($MBR$, $ptr$) and a leaf node entry is of the form ($MBR$, $oid$), where $MBR$ is the minimum bounding rectangle for child, $ptr$ is a pointer to the child node, and $oid$ is the identifier for the object in the database. In this traditional R-tree, nodes correspond to pages.

In contrast our GAE implementation stores nodes as a key-value pair (key=$key$, value=$entries$), where $key$ is a unique automatically generated value and $entries$ is a list containing data about the node's children. The entries in $entries$ are blob-serialized using Python's \textit{cPickle} module and are of the form ($MBR$, $child\_key$), where $child\_key$ refers to the Datastore object containing the child node. If it is a leaf node, $child\_key$ is \textit{None} for all entries. In order to refer to a child node within an entry, the entry needs to know the node's key identifier in the data store. Therefore, tree storage needs to happen bottom up: we have to start with leaf nodes, whose entries do not have child nodes, obtain their key identifier from the data store, update the reference in their respective parent entry, and so on. To keep track of the root of the R-tree, we store an object containing metadata about the structure in the Datastore. This metadata object stores information such as the root key, the page size, and the minimum number of entries per node. By checking whether the metadata is present, we can infer whether there is a tree saved in the data store or not.

Insertion and search are performed as described by Guttman\cite{DBLP:conf/sigmod/Guttman84} except we navigate to different nodes using keys instead of pointers. Our implementation also uses the quadratic split algorithm discussed in the paper on an overflow. Currently we do not have a working delete algorithm, but since our present data set is static it is acceptable. We thus leave the delete function as a future task.

\TODO{add a descriptive graphic}

\TODO{Add more explaining prose about the key-value design in app engine}

\subsection{Navigation Algorithm}
\input{nav.tex}
\bibliographystyle{abbrv}
\bibliography{main}

\end{document}
